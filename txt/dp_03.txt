IF OBJECT_ID('tempdb..#AlwaysOnInfo') IS NOT NULL
BEGIN
    DROP TABLE #AlwaysOnInfo;
END

IF OBJECT_ID('tempdb..#ServerInfo') IS NOT NULL
BEGIN
    DROP TABLE #ServerInfo;
END


IF OBJECT_ID('tempdb..#DatabaseAutoCloseInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseAutoCloseInfo;
END


IF OBJECT_ID('tempdb..#ServerConfiguration') IS NOT NULL
BEGIN
    DROP TABLE #ServerConfiguration;
END

IF OBJECT_ID('tempdb..#TotalMemory') IS NOT NULL
BEGIN
    DROP TABLE #TotalMemory;
END

IF OBJECT_ID('tempdb..#MinServerMemory') IS NOT NULL
BEGIN
    DROP TABLE #MinServerMemory;
END

IF OBJECT_ID('tempdb..#MaxServerMemory') IS NOT NULL
BEGIN
    DROP TABLE #MaxServerMemory;
END

IF OBJECT_ID('tempdb..#BackupCompressionInfo') IS NOT NULL
BEGIN
    DROP TABLE #BackupCompressionInfo;
END

IF OBJECT_ID('tempdb..#DatabaseCPUUsage') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseCPUUsage;
END

IF OBJECT_ID('tempdb..#DatabaseFileInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseFileInfo;
END

IF OBJECT_ID('tempdb..#BackupDetails') IS NOT NULL
BEGIN
    DROP TABLE #BackupDetails;
END

IF OBJECT_ID('tempdb..#DatabaseSizeInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseSizeInfo;
END

IF OBJECT_ID('tempdb..#DbGrowth') IS NOT NULL
BEGIN
    DROP TABLE #DbGrowth;
END

IF OBJECT_ID('tempdb..#DeadlockPerformance') IS NOT NULL
BEGIN
    DROP TABLE #DeadlockPerformance;
END


IF OBJECT_ID('tempdb..#DatabasePageVerifyInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabasePageVerifyInfo;
END

IF OBJECT_ID('tempdb..#DatabaseCompatibilityInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseCompatibilityInfo;
END

IF OBJECT_ID('tempdb..#DatabaseAutoShrinkInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseAutoShrinkInfo;
END



IF OBJECT_ID('tempdb..#DatabaseLogInfo') IS NOT NULL
BEGIN
    DROP TABLE #DatabaseLogInfo;
END

IF OBJECT_ID('tempdb..#JobHistory') IS NOT NULL
BEGIN
    DROP TABLE #JobHistory;
END

IF OBJECT_ID('tempdb..#ORPHANUSER') IS NOT NULL
BEGIN
    DROP TABLE #ORPHANUSER;
END


IF OBJECT_ID('tempdb..#EmptyPasswordLogins') IS NOT NULL
BEGIN
    DROP TABLE #EmptyPasswordLogins;
END




IF OBJECT_ID('tempdb..#ServerPrincipals') IS NOT NULL
BEGIN
    DROP TABLE #ServerPrincipals;
END

IF OBJECT_ID('tempdb..#ServerLevelPermissions') IS NOT NULL
BEGIN
    DROP TABLE #ServerLevelPermissions;
END

IF OBJECT_ID('tempdb..#ServerLogins') IS NOT NULL
BEGIN
    DROP TABLE #ServerLogins;
END

IF OBJECT_ID('tempdb..#DBLevelPermissions') IS NOT NULL
BEGIN
    DROP TABLE #DBLevelPermissions;
END



----------------------------AO_information------------------------------
CREATE TABLE #AlwaysOnInfo (
    AvailabilityGroupName NVARCHAR(255),
    ReplicaServerName NVARCHAR(255),
    AvailabilityMode NVARCHAR(255),
    FailoverMode NVARCHAR(255)
);

-- Always On kontrolu
IF SERVERPROPERTY('IsHadrEnabled') = 1
BEGIN
    -- Always On etkinse, Availability Groups ve Replica bilgilerini tabloya ekler
    INSERT INTO #AlwaysOnInfo
    SELECT
        ag.name AS [AvailabilityGroupName],
        ar.replica_server_name AS [ReplicaServerName],
        ar.availability_mode_desc AS [AvailabilityMode],
        ar.failover_mode_desc AS [FailoverMode]
    FROM
        sys.availability_groups ag
    INNER JOIN
        sys.availability_replicas ar ON ag.group_id = ar.group_id;


END
-------------------------------------------serverinfo---------------------------------------------------

IF OBJECT_ID('tempdb..#ServerInfo') IS NOT NULL
BEGIN
    DROP TABLE #ServerInfo;
END

CREATE TABLE #ServerInfo (
    Instance NVARCHAR(255),
    Edition NVARCHAR(255),
    [Version] NVARCHAR(255),
    Collation NVARCHAR(255),
    CPU INT,
    [RAM (MB)] INT,
    Cluster NVARCHAR(50),
    HA NVARCHAR(50),
    [Sanal Server] NVARCHAR(50),
    OS NVARCHAR(255),
    [Cumulative Update] NVARCHAR(50),
    [SQL Version] NVARCHAR(50),
    create_date DATETIME
);

DECLARE @Version INT;
SET @Version = CONVERT(INT, LEFT(CONVERT(VARCHAR, SERVERPROPERTY('ProductVersion')), CHARINDEX('.', CONVERT(VARCHAR, SERVERPROPERTY('ProductVersion'))) - 1));

IF @Version >= 14 -- SQL Server 2017 ve sonrasi
BEGIN
    INSERT INTO #ServerInfo
    SELECT
        CONVERT(NVARCHAR(255), SERVERPROPERTY('MachineName')) AS [Instance],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('Edition')) AS [Edition],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('ProductVersion')) AS [Version],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('Collation')) AS [Collation],
        cpu_count AS [CPU],
        physical_memory_kb / 1024 AS [RAM (MB)],
        CONVERT(NVARCHAR(50), SERVERPROPERTY('IsClustered')) AS [Cluster],
        CONVERT(NVARCHAR(50), SERVERPROPERTY('IsHadrEnabled')) AS [HA],
        CASE
            WHEN EXISTS (SELECT 1 FROM sys.dm_os_sys_info WHERE virtual_machine_type_desc = 'NONE') THEN 'No'
            ELSE 'Yes'
        END AS [Sanal Server],
        (SELECT TOP 1 host_platform FROM sys.dm_os_host_info) AS [OS],
         CASE
         WHEN COALESCE(CONVERT(varchar(30), SERVERPROPERTY('ProductUpdateLevel')), '') <> ''
              THEN CONVERT(varchar(30), SERVERPROPERTY('ProductUpdateLevel')) 
         ELSE 'RTM'
       END AS [Cumulative Update],
         CASE
            WHEN @Version = 16 THEN 'SQL Server 2022'
            WHEN @Version = 15 THEN 'SQL Server 2019'
            WHEN @Version = 14 THEN 'SQL Server 2017'
            ELSE 'Bilinmiyor'
        END AS [SQL Version],
        GETDATE() AS create_date
    FROM sys.dm_os_sys_info;



END
ELSE -- SQL Server 2016 ve oncesi
BEGIN
    INSERT INTO #ServerInfo
    SELECT
        CONVERT(NVARCHAR(255), SERVERPROPERTY('MachineName')) AS [Instance],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('Edition')) AS [Edition],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('ProductVersion')) AS [Version],
        CONVERT(NVARCHAR(255), SERVERPROPERTY('Collation')) AS [Collation],
        cpu_count AS [CPU],
        physical_memory_kb / 1024 AS [RAM (MB)],
        CONVERT(NVARCHAR(50), SERVERPROPERTY('IsClustered')) AS [Cluster],
        CONVERT(NVARCHAR(50), SERVERPROPERTY('IsHadrEnabled')) AS [HA],
        'Unknown' AS [Sanal Server],
        'Unknown' AS [OS],
        CASE
            WHEN @@VERSION LIKE '%CU%' THEN
                'CU' + SUBSTRING(@@VERSION, CHARINDEX('CU', @@VERSION) + 2, CHARINDEX(')', @@VERSION, CHARINDEX('CU', @@VERSION)) - CHARINDEX('CU', @@VERSION) - 2)
            ELSE 'RTM'
        END AS [Cumulative Update],
        CASE
            WHEN @Version = 13 THEN 'SQL Server 2016'
            WHEN @Version = 12 THEN 'SQL Server 2014'
            WHEN @Version = 11 THEN 'SQL Server 2012'
            WHEN @Version = 10 THEN 'SQL Server 2008/R2'
            WHEN @Version = 9 THEN 'SQL Server 2005'
            ELSE 'Bilinmiyor'
        END AS [SQL Version],
        GETDATE() AS create_date
    FROM sys.dm_os_sys_info;



END;


-------------------------------------configuration------------------------------------------

DECLARE @AdvancedOptionsEnabled BIT;
DECLARE @InitialSetting BIT;

-- 'show advanced options' açık mı kontrol et
IF EXISTS (SELECT * FROM sys.configurations WHERE name = 'show advanced options' AND value_in_use = 1)
BEGIN
    SET @AdvancedOptionsEnabled = 1;
END
ELSE
BEGIN
    SET @AdvancedOptionsEnabled = 0;
END

SET @InitialSetting = @AdvancedOptionsEnabled;

-- Eğer kapalıysa aç
IF @AdvancedOptionsEnabled = 0
BEGIN
    -- Transaction dışında sp_configure kullanımı
    BEGIN TRY
        EXEC sp_configure 'show advanced options', 1;
        RECONFIGURE;
    END TRY
    BEGIN CATCH
        PRINT 'show advanced options ayarı açılamadı!';
        RETURN;
    END CATCH
END

-- Temp tablo oluştur


CREATE TABLE #ServerConfiguration (
    ConfigName NVARCHAR(100),
    ConfigValue INT
);

-- Değerleri temp tabloya yaz
INSERT INTO #ServerConfiguration (ConfigName, ConfigValue)
SELECT name AS ConfigName, CONVERT(INT, value_in_use) AS ConfigValue
FROM sys.configurations
WHERE name IN ('max degree of parallelism', 'cost threshold for parallelism', 'optimize for ad hoc workloads');




-- Eğer başlangıçta kapalıysa geri kapat
IF @InitialSetting = 0
BEGIN
    -- Transaction dışında sp_configure kullanımı
    BEGIN TRY
        EXEC sp_configure 'show advanced options', 0;
        RECONFIGURE;
    END TRY
    BEGIN CATCH
        PRINT 'show advanced options ayarı kapatılamadı!';
        RETURN;
    END CATCH
END
-----------------------------max-minMemory-------------------------------------
DECLARE @xpCmdShellEnabled BIT;


-- 'show advanced options' açık mı kontrol et
IF EXISTS (SELECT * FROM sys.configurations WHERE name = 'show advanced options' AND value_in_use = 1)
BEGIN
    SET @AdvancedOptionsEnabled = 1;
END
ELSE
BEGIN
    SET @AdvancedOptionsEnabled = 0;
END

SET @InitialSetting = @AdvancedOptionsEnabled;

-- Eğer kapalıysa aç (transaction dışına alındı)
IF @AdvancedOptionsEnabled = 0
BEGIN
    BEGIN TRY
        EXEC sp_configure 'show advanced options', 1;
        RECONFIGURE;
    END TRY
    BEGIN CATCH
        PRINT 'show advanced options açılırken hata oluştu.';
        RETURN;
    END CATCH
END

-- Toplam bellek için temp tablo oluştur


CREATE TABLE #TotalMemory (
    TotalMemory_MB INT
);

INSERT INTO #TotalMemory
SELECT physical_memory_kb / 1024 AS TotalMemory_MB -- Toplam RAM (MB)
FROM sys.dm_os_sys_info;

-- Minimum bellek yapılandırma tablosu oluştur

CREATE TABLE #MinServerMemory (
    name NVARCHAR(255),
    minimum INT,
    maximum INT,
    config_value INT,
    run_value INT
);

INSERT INTO #MinServerMemory
EXEC sp_configure 'min server memory';



CREATE TABLE #MaxServerMemory (
    name NVARCHAR(255),
    minimum INT,
    maximum INT,
    config_value INT,
    run_value INT
);

INSERT INTO #MaxServerMemory
EXEC sp_configure 'max server memory';

-- Eğer başlangıçta kapalıysa geri kapat (transaction dışına alındı)
IF @InitialSetting = 0
BEGIN
    BEGIN TRY
        EXEC sp_configure 'show advanced options', 0;
        RECONFIGURE;
    END TRY
    BEGIN CATCH
        PRINT 'show advanced options kapatılırken hata oluştu.';
        RETURN;
    END CATCH
END



---------------------------------------backupCompression-------------------------------------------------
-- Create temporary table for backup compression information
CREATE TABLE #BackupCompressionInfo (
    ConfigurationName NVARCHAR(255),
    ConfiguredValue NVARCHAR(255),
    CompressionBackup NVARCHAR(255),
    Description NVARCHAR(MAX)
);

-- Insert data into the temporary table
INSERT INTO #BackupCompressionInfo
SELECT
    name AS ConfigurationName,
    CONVERT(NVARCHAR(255), value) AS ConfiguredValue,
    CONVERT(NVARCHAR(255), value_in_use) AS CompressionBackup,
    description
FROM
    sys.configurations
WHERE
    name = 'backup compression default';



----------------------------------CPUutilization------------------------------------------
-- Create temporary table for CPU utilization by database
CREATE TABLE #DatabaseCPUUsage (
    [CPU Rank] INT,
    [Database Name] NVARCHAR(128),
    [CPU Time (ms)] BIGINT,
    [CPU Percent] DECIMAL(5, 2)
);

-- Insert data into the temporary table
;WITH DB_CPU_Stats AS
(
    SELECT
        pa.DatabaseID,
        DB_Name(pa.DatabaseID) AS [Database Name],
        SUM(qs.total_worker_time / 1000) AS [CPU_Time_Ms]
    FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
    CROSS APPLY
    (
        SELECT CONVERT(INT, value) AS [DatabaseID]
        FROM sys.dm_exec_plan_attributes(qs.plan_handle)
        WHERE attribute = N'dbid'
    ) AS pa
    GROUP BY pa.DatabaseID
)
INSERT INTO #DatabaseCPUUsage
SELECT
    ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
    [Database Name],
    [CPU_Time_Ms] AS [CPU Time (ms)],
    CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- Exclude ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);



-- Identify the database with the highest CPU utilization
DECLARE @TargetDatabase NVARCHAR(128);
;WITH DB_CPU_Stats AS
(
    SELECT
        pa.DatabaseID,
        DB_Name(pa.DatabaseID) AS [Database Name],
        SUM(qs.total_worker_time / 1000) AS [CPU_Time_Ms]
    FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
    CROSS APPLY
    (
        SELECT CONVERT(INT, value) AS [DatabaseID]
        FROM sys.dm_exec_plan_attributes(qs.plan_handle)
        WHERE attribute = N'dbid'
    ) AS pa
    GROUP BY pa.DatabaseID
)
SELECT TOP 1 @TargetDatabase = [Database Name]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- Exclude ResourceDB
ORDER BY [CPU_Time_Ms] DESC;

-- Print the name of the target database for monitoring
PRINT 'Target Database: ' + ISNULL(@TargetDatabase, 'No target database found.');

-- Stop script execution if no database is found
IF @TargetDatabase IS NULL
BEGIN
    PRINT 'No target database found. Exiting script.';
    RETURN;
END;


--------------------------------------Database File Paths------------------------------------
-- Drop the table if it already exists


-- Create a temporary table for database file information
CREATE TABLE #DatabaseFileInfo (
    [Database Name] NVARCHAR(255),
    [file_id] INT,
    [name] NVARCHAR(255),
    physical_name NVARCHAR(255),
    [type_desc] NVARCHAR(50),
    state_desc NVARCHAR(50),
    is_percent_growth BIT,
    growth INT,
    [Growth in MB] BIGINT,
    [Total Size in MB] BIGINT,
    max_size BIGINT
);

-- Insert data into the temporary table
INSERT INTO #DatabaseFileInfo
SELECT
    DB_NAME([database_id]) AS [Database Name],
    [file_id], [name], physical_name, [type_desc], state_desc,
    is_percent_growth, growth,
    CONVERT(BIGINT, growth / 128.0) AS [Growth in MB],
    CONVERT(BIGINT, size / 128.0) AS [Total Size in MB], max_size
FROM sys.master_files WITH (NOLOCK)
ORDER BY DB_NAME([database_id]), [file_id] OPTION (RECOMPILE);



---------------------------Backup history-----------------------------
-- Create a temporary table for backup details
CREATE TABLE #BackupDetails (
    Server NVARCHAR(100),
    database_name NVARCHAR(255),
    backup_start_date DATETIME,
    backup_finish_date DATETIME,
    expiration_date DATETIME,
    backup_type NVARCHAR(50),
    [Backup Size in MB] NVARCHAR(50),
    [Comp Size in MB] NVARCHAR(50),
    logical_device_name NVARCHAR(255),
    physical_device_name NVARCHAR(255),
    backupset_name NVARCHAR(255),
    description NVARCHAR(MAX)
);

-- Insert data into the temporary table
INSERT INTO #BackupDetails
SELECT
    CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server,
    bs.database_name,
    bs.backup_start_date,
    bs.backup_finish_date,
    bs.expiration_date,
    CASE bs.type
        WHEN 'D' THEN 'Full Database'
        WHEN 'L' THEN 'Log'
        WHEN 'I' THEN 'Differential'
        WHEN 'F' THEN 'File Level'
        WHEN 'G' THEN 'File Level Differential'
        WHEN 'P' THEN 'Partial'
        WHEN 'Q' THEN 'Differential partial'
    END AS backup_type,
    CONVERT(VARCHAR, CAST(bs.backup_size / 1024 / 1024 AS MONEY), 10) AS [Backup Size in MB],
    CONVERT(VARCHAR, CAST(bs.compressed_backup_size / 1024 / 1024 AS MONEY), 10) AS [Comp Size in MB],
    bmf.logical_device_name,
    bmf.physical_device_name,
    bs.name AS backupset_name,
    bs.description
FROM msdb.dbo.backupmediafamily bmf
INNER JOIN msdb.dbo.backupset bs ON bmf.media_set_id = bs.media_set_id
WHERE (CONVERT(DATETIME, bs.backup_start_date, 102) >= GETDATE() - 10)
ORDER BY
    bs.database_name,
    bs.backup_finish_date;



------------------------DatabaseSize---------------------------------
-- Create a temporary table for database size information
CREATE TABLE #DatabaseSizeInfo (
    DatabaseName NVARCHAR(255),
    LogSizeGB DECIMAL(18, 2),
    TotalSizeGB DECIMAL(18, 2)
);

-- Insert data into the temporary table
INSERT INTO #DatabaseSizeInfo
SELECT
    DatabaseName = DB_NAME(database_id),
    LogSizeGB = CAST(SUM(CASE WHEN type_desc = 'LOG' THEN size END) * 8. / 1024 / 1024 AS DECIMAL(18, 2)),
    TotalSizeGB = CAST(SUM(size) * 8. / 1024 / 1024 AS DECIMAL(18, 2))
FROM sys.master_files WITH (NOLOCK)
WHERE database_id > 4
GROUP BY database_id
ORDER BY TotalSizeGB DESC;



------------------------Buyume Oranlar--------------------------------
DECLARE @startDate DATETIME;
SET @startDate = GETDATE();

-- Create a temporary table for backup growth statistics
CREATE TABLE #DbGrowth (
    DatabaseName NVARCHAR(255),
    [0] NUMERIC(10, 1),
    [-1] NUMERIC(10, 1),
    [-2] NUMERIC(10, 1),
    [-3] NUMERIC(10, 1),
    [-4] NUMERIC(10, 1),
    [-5] NUMERIC(10, 1),
    [-6] NUMERIC(10, 1),
    [-7] NUMERIC(10, 1),
    [-8] NUMERIC(10, 1),
    [-9] NUMERIC(10, 1),
    [-10] NUMERIC(10, 1),
    [-11] NUMERIC(10, 1),
    [-12] NUMERIC(10, 1)
);

-- Insert data into the temporary table
INSERT INTO #DbGrowth
SELECT PVT.DatabaseName,
       ISNULL(PVT.[0], 0) AS [0],
       ISNULL(PVT.[-1], 0) AS [-1],
       ISNULL(PVT.[-2], 0) AS [-2],
       ISNULL(PVT.[-3], 0) AS [-3],
       ISNULL(PVT.[-4], 0) AS [-4],
       ISNULL(PVT.[-5], 0) AS [-5],
       ISNULL(PVT.[-6], 0) AS [-6],
       ISNULL(PVT.[-7], 0) AS [-7],
       ISNULL(PVT.[-8], 0) AS [-8],
       ISNULL(PVT.[-9], 0) AS [-9],
       ISNULL(PVT.[-10], 0) AS [-10],
       ISNULL(PVT.[-11], 0) AS [-11],
       ISNULL(PVT.[-12], 0) AS [-12]
FROM
   (SELECT BS.database_name AS DatabaseName,
          DATEDIFF(mm, @startDate, BS.backup_start_date) AS MonthsAgo,
          CONVERT(NUMERIC(10, 1), AVG(BF.file_size / 1048576.0)) AS AvgSizeMB
    FROM msdb.dbo.backupset AS BS
    INNER JOIN msdb.dbo.backupfile AS BF
        ON BS.backup_set_id = BF.backup_set_id
    WHERE NOT BS.database_name IN ('master', 'msdb', 'model', 'tempdb')
      AND BF.[file_type] = 'D'
      AND BS.backup_start_date BETWEEN DATEADD(yy, -1, @startDate) AND @startDate
    GROUP BY BS.database_name, DATEDIFF(mm, @startDate, BS.backup_start_date)
    ) AS BCKSTAT
PIVOT (SUM(BCKSTAT.AvgSizeMB)
       FOR BCKSTAT.MonthsAgo IN ([0], [-1], [-2], [-3], [-4], [-5], [-6], [-7], [-8], [-9], [-10], [-11], [-12])
      ) AS PVT;


------------------------Deadlock------------------------------------------
-- Create a temporary table for deadlock performance statistics
CREATE TABLE #DeadlockPerformance (
    object_name NVARCHAR(255),
    counter_name NVARCHAR(255),
    CounterValue_Total BIGINT,
    CounterValue_Per_Sec FLOAT,
    CounterValue_Per_Day FLOAT,
    UpTime_Sec BIGINT,
    UpTime_Day FLOAT
);

-- Insert data into the temporary table
INSERT INTO #DeadlockPerformance
SELECT
    pc.object_name,
    pc.counter_name,
    pc.cntr_value AS CounterValue_Total,
    pc.cntr_value * 0.1 / ut.UpTimeSec AS CounterValue_Per_Sec,
    pc.cntr_value * 3600. * 24 / ut.UpTimeSec AS CounterValue_Per_Day,
    ut.UpTimeSec AS UpTime_Sec,
    ut.UpTimeSec / 3600. / 24 AS UpTime_Day
FROM sys.dm_os_performance_counters pc
CROSS JOIN (
    SELECT DATEDIFF(SECOND, sqlserver_start_time, CURRENT_TIMESTAMP) AS UpTimeSec
    FROM sys.dm_os_sys_info
) ut
WHERE pc.counter_name = 'Number of Deadlocks/sec' AND pc.instance_name = '_Total';




----------------------------CHECKDB---------------------------------------

--------------------------[Page Verify Option]-----------------------------
-- Create temporary table for Page Verify Option
CREATE TABLE #DatabasePageVerifyInfo (
    [Database Name] NVARCHAR(255),
    [Page Verify Option] NVARCHAR(255)
);

-- Insert data into the temporary table
INSERT INTO #DatabasePageVerifyInfo
SELECT
    db.[name] AS [Database Name],
    db.page_verify_option_desc AS [Page Verify Option]
FROM sys.databases AS db WITH (NOLOCK)
ORDER BY db.[name] OPTION (RECOMPILE);



------------------------[DB Compatibility Level]--------------------------
-- Create temporary table for Compatibility Level
CREATE TABLE #DatabaseCompatibilityInfo (
    [Database Name] NVARCHAR(255),
    [DB Compatibility Level] INT
);

-- Insert data into the temporary table
INSERT INTO #DatabaseCompatibilityInfo
SELECT
    db.[name] AS [Database Name],
    db.[compatibility_level] AS [DB Compatibility Level]
FROM sys.databases AS db WITH (NOLOCK)
ORDER BY db.[name] OPTION (RECOMPILE);



-------------------------is_auto_close_on--------------------------
-- Create temporary table for Auto Close info
CREATE TABLE #DatabaseAutoCloseInfo (
    [Database Name] NVARCHAR(255),
    is_auto_close_on BIT
);

-- Insert data into the temporary table
INSERT INTO #DatabaseAutoCloseInfo
SELECT
    db.[name] AS [Database Name],
    db.is_auto_close_on
FROM sys.databases AS db WITH (NOLOCK)
ORDER BY db.[name] OPTION (RECOMPILE);


---------------------------------is_auto_shrink_on-----------------
-- Create temporary table for Auto Shrink info
CREATE TABLE #DatabaseAutoShrinkInfo (
    [Database Name] NVARCHAR(255),
    is_auto_shrink_on BIT
);

-- Insert data into the temporary table
INSERT INTO #DatabaseAutoShrinkInfo
SELECT
    db.[name] AS [Database Name],
    db.is_auto_shrink_on
FROM sys.databases AS db WITH (NOLOCK)
ORDER BY db.[name] OPTION (RECOMPILE);




------------------[Recovery Model]--------------------------------
-- Create a temporary table for Recovery Model
CREATE TABLE #DatabaseLogInfo (
    [Database Name] NVARCHAR(255),
    [Recovery Model] NVARCHAR(255)
);

-- Insert data into the temporary table
INSERT INTO #DatabaseLogInfo
SELECT
    db.[name] AS [Database Name],
    db.recovery_model_desc AS [Recovery Model]
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
    ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
    ON db.name = ls.instance_name
LEFT OUTER JOIN sys.dm_database_encryption_keys AS de WITH (NOLOCK)
    ON db.database_id = de.database_id
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%'
  AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
  AND ls.cntr_value > 0
ORDER BY db.[name] OPTION (RECOMPILE);



------------------[Job History]--------------------------------
-- Create a temporary table for Job History
CREATE TABLE #JobHistory (
    JobName NVARCHAR(255),
    LastRunDuration NVARCHAR(20),
    LastRunTime DATETIME,
    RunStatus NVARCHAR(50),
    Status NVARCHAR(50)
);

-- Insert data into the temporary table
INSERT INTO #JobHistory
SELECT
    sjo.name AS JobName,
    ISNULL(
        CASE
            WHEN sjh.run_duration IS NULL THEN 'NONE'
            ELSE CONVERT(VARCHAR(20), sjh.run_duration / 10000) + ':' +
                 RIGHT('0' + CONVERT(VARCHAR(2), (sjh.run_duration / 100) % 100), 2) + ':' +
                 RIGHT('0' + CONVERT(VARCHAR(2), sjh.run_duration % 100), 2)
        END, 'NONE') AS LastRunDuration,
    ISNULL(
        CASE
            WHEN msdb.dbo.agent_datetime(sjh.run_date, sjh.run_time) IS NULL THEN '1900-01-01 00:00:00'
            ELSE msdb.dbo.agent_datetime(sjh.run_date, sjh.run_time)
        END, '1900-01-01 00:00:00') AS LastRunTime,
    ISNULL(CASE sjh.run_status
        WHEN 0 THEN 'Failed'
        WHEN 1 THEN 'Succeeded'
        ELSE 'NONE'
    END, 'NONE') AS RunStatus,
    ISNULL(CASE sjo.enabled
        WHEN 1 THEN 'Enable'
        WHEN 0 THEN 'Disable'
        ELSE 'NONE'
    END, 'NONE') AS Status
FROM msdb.dbo.sysjobs sjo
LEFT JOIN msdb.dbo.sysjobhistory sjh
    ON sjo.job_id = sjh.job_id
    AND sjh.instance_id = (
        SELECT MAX(instance_id)
        FROM msdb.dbo.sysjobhistory
        WHERE sysjobhistory.job_id = sjo.job_id
    )
ORDER BY LastRunTime DESC;


------------------------Orphan Users ES-----------------------------------------------------
CREATE TABLE #ORPHANUSER (
    DBNAME VARCHAR(100),
    USERNAME VARCHAR(100),
    CREATEDATE VARCHAR(100),
    USERTYPE VARCHAR(100)
);

-- Insert data into the table
EXEC sp_MSforeachdb '
USE [?];
INSERT INTO #ORPHANUSER
SELECT
    DB_NAME() AS DBNAME,
    NAME AS USERNAME,
    CREATEDATE,
    CASE
        WHEN ISNTGROUP = 0 AND ISNTUSER = 0 THEN ''SQL LOGIN''
        WHEN ISNTGROUP = 1 THEN ''NT GROUP''
        WHEN ISNTGROUP = 0 AND ISNTUSER = 1 THEN ''NT LOGIN''
    END AS USERTYPE
FROM sys.sysusers
WHERE SID IS NOT NULL
  AND SID <> 0X0
  AND ISLOGIN = 1
  AND SID NOT IN (SELECT SID FROM sys.syslogins)
  AND NAME NOT IN (''dbo'', ''MS_DataCollectorInternalUser'')
';



--------------------------securityAuditHC-----------------------------
CREATE TABLE #EmptyPasswordLogins (
    name NVARCHAR(255),
    type_desc NVARCHAR(255),
    create_date DATETIME,
    modify_date DATETIME,
    password_hash VARBINARY(MAX)
);

BEGIN
    INSERT INTO #EmptyPasswordLogins
    SELECT name, type_desc, create_date, modify_date, password_hash
    FROM sys.sql_logins
    WHERE PWDCOMPARE(CONVERT(NVARCHAR(4000), ''), password_hash) = 1; -- Check for empty passwords


END
------------------------Disable Logins-----------------------
CREATE TABLE #ServerLogins (

    name SYSNAME,
    is_disabled INT,
    type_desc VARCHAR(60),
    create_date DATETIME,
    modify_date DATETIME,
    server_roles VARCHAR(MAX),
    db_roles VARCHAR(MAX)
);

CREATE TABLE #DBLevelPermissions (
    sid_ VARCHAR(400),
    DBName SYSNAME,
    DBRole SYSNAME,
    MemberName SYSNAME
);

-- Gather server-level permissions
SELECT sid, CONVERT(SYSNAME, LGN.name) AS Name, SUSER_NAME(RM.role_principal_id) AS RoleName
INTO #ServerLevelPermissions
FROM sys.server_role_members RM
INNER JOIN sys.server_principals LGN
    ON RM.member_principal_id = LGN.principal_id
WHERE RM.role_principal_id >= 3 AND RM.role_principal_id <= 10;

-- Gather server principals
SELECT sid, name, is_disabled, type_desc, create_date, modify_date
INTO #ServerPrincipals
FROM sys.server_principals
WHERE type NOT IN ('C', 'R')
  AND name NOT IN ('sa', 'recon', '##MS_PolicyTsqlExecutionLogin##', '##MS_PolicyEventProcessingLogin##',
                   'NT AUTHORITY\\SYSTEM', 'NT AUTHORITY\\NETWORK SERVICE',
                   'NT SERVICE\\MSSQLSERVER', 'NT SERVICE\\SQLSERVERAGENT');

-- Gather database-level permissions
EXEC sp_MSforeachdb 'USE [?];
INSERT INTO #DBLevelPermissions
SELECT u.sid, DB_NAME() AS DBName, g.name AS DBRole, u.name AS MemberName
FROM sys.database_principals u
INNER JOIN sys.database_role_members m ON u.principal_id = m.member_principal_id
INNER JOIN sys.database_principals g ON g.principal_id = m.role_principal_id;';

-- Process login information
DECLARE @str1 VARCHAR(MAX), @str2 VARCHAR(MAX), @sid_ VARCHAR(400), @name SYSNAME;
DECLARE @is_disabled INT, @type_desc VARCHAR(60), @create_date DATETIME, @modify_date DATETIME;
SET @str1 = '';
SET @str2 = '';

DECLARE CursorX CURSOR FOR
SELECT sid, name, is_disabled, type_desc, create_date, modify_date
FROM #ServerPrincipals;

OPEN CursorX;
FETCH NEXT FROM CursorX INTO @sid_, @name, @is_disabled, @type_desc, @create_date, @modify_date;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @str1 = '';
    SELECT @str1 += RoleName + ',' FROM #ServerLevelPermissions WHERE Name = CONVERT(SYSNAME, @name);
    IF @str1 <> '' SET @str1 = LEFT(@str1, LEN(@str1) - 1);

    SET @str2 = '';
    SELECT @str2 += DBName + '(''' + DBRole + '''),' FROM #DBLevelPermissions WHERE sid_ = CONVERT(VARCHAR(400), @sid_);
    IF @str2 <> '' SET @str2 = LEFT(@str2, LEN(@str2) - 1);

    INSERT INTO #ServerLogins
    SELECT  @name, @is_disabled, @type_desc, @create_date, @modify_date, @str1, @str2;

    FETCH NEXT FROM CursorX INTO @sid_, @name, @is_disabled, @type_desc, @create_date, @modify_date;
END

CLOSE CursorX;
DEALLOCATE CursorX;

-- Return disabled logins







    -- Sonuçları döndür
SELECT * FROM #AlwaysOnInfo;
SELECT * FROM #ServerInfo;
SELECT * FROM #ServerConfiguration;
SELECT * FROM #TotalMemory;
SELECT * FROM #MinServerMemory;
SELECT * FROM #MaxServerMemory;
SELECT * FROM #BackupCompressionInfo;
SELECT * FROM #DatabaseCPUUsage;
SELECT * FROM #DatabaseFileInfo;
SELECT * FROM #BackupDetails;
SELECT * FROM #DatabaseSizeInfo;
SELECT * FROM #DbGrowth;
SELECT * FROM #DeadlockPerformance;
SELECT * FROM #DatabasePageVerifyInfo;
SELECT * FROM #DatabaseCompatibilityInfo;
SELECT * FROM #DatabaseAutoShrinkInfo;
SELECT * FROM #DatabaseAutoCloseInfo;
SELECT * FROM #DatabaseLogInfo;
SELECT * FROM #JobHistory;
SELECT * FROM #ORPHANUSER;
SELECT * FROM #EmptyPasswordLogins;
SELECT * FROM #ServerLogins;



